import React, { useState } from 'react';
import { motion } from 'framer-motion';
import SafeIcon from '../common/SafeIcon';
import supabase from '../lib/supabase';
import * as FiIcons from 'react-icons/fi';

const { FiPlus, FiTrash2, FiEdit3, FiClock, FiTarget, FiZap, FiCheckCircle, FiMapPin, FiSave } = FiIcons;

const StoryStructureBuilder = ({ project, onDataUpdate }) => {
  const [newSegment, setNewSegment] = useState({
    title: '',
    description: '',
    duration: '30 seconds',
    act: 'setup',
    location: '',
    location_type: 'Indoor',
    location_notes: ''
  });
  const [generatingScenes, setGeneratingScenes] = useState(false);

  const acts = [
    {
      id: 'setup',
      title: 'Setup (Act 1)',
      description: 'Introduce characters, world, and establish the normal state',
      icon: FiTarget,
      color: 'from-blue-500 to-cyan-500',
      tips: [
        'Introduce your main character or subject',
        'Establish the setting and context',
        'Hook the audience with an engaging opening',
        'Set up what the video will be about'
      ]
    },
    {
      id: 'conflict',
      title: 'Conflict (Act 2)',
      description: 'Present the main challenge, problem, or journey',
      icon: FiZap,
      color: 'from-orange-500 to-red-500',
      tips: [
        'Present the main challenge or problem',
        'Show the journey or process',
        'Build tension and engagement',
        'This should be your longest section'
      ]
    },
    {
      id: 'resolution',
      title: 'Resolution (Act 3)',
      description: 'Resolve the conflict and provide conclusion',
      icon: FiCheckCircle,
      color: 'from-green-500 to-emerald-500',
      tips: [
        'Resolve the main conflict or show results',
        'Provide key takeaways or lessons',
        'End with a call-to-action',
        'Leave audience satisfied'
      ]
    }
  ];

  const locationTypes = ['Indoor', 'Outdoor', 'Studio', 'Public Space', 'Private Property', 'Virtual/Green Screen'];

  const handleAddSegment = () => {
    if (!newSegment.title.trim()) return;

    const segments = project.story_structure || [];
    const segment = {
      id: Date.now(),
      ...newSegment,
      order_index: segments.length + 1
    };

    onDataUpdate({ story_structure: [...segments, segment] });
    setNewSegment({
      title: '',
      description: '',
      duration: '30 seconds',
      act: 'setup',
      location: '',
      location_type: 'Indoor',
      location_notes: ''
    });
  };

  const removeSegment = (segmentId) => {
    const segments = project.story_structure || [];
    onDataUpdate({
      story_structure: segments.filter(segment => segment.id !== segmentId)
    });
  };

  const updateSegment = (segmentId, updates) => {
    const segments = project.story_structure || [];
    onDataUpdate({
      story_structure: segments.map(segment =>
        segment.id === segmentId ? { ...segment, ...updates } : segment
      )
    });
  };

  const getSegmentsByAct = (actId) => {
    const segments = project.story_structure || [];
    return segments.filter(segment => segment.act === actId);
  };

  const generateScenesFromStructure = async () => {
    const segments = project.story_structure || [];
    if (segments.length === 0) {
      alert('Please add story segments first before generating scenes.');
      return;
    }

    setGeneratingScenes(true);
    try {
      console.log('Generating scenes from segments:', segments);
      console.log('Project ID:', project.id);

      // First, delete existing scenes for this project to avoid conflicts
      const { error: deleteError } = await supabase
        .from('scenes_fc2024')
        .delete()
        .eq('project_id', project.id);

      if (deleteError) {
        console.warn('Could not delete existing scenes:', deleteError);
        // Continue anyway as the table might not exist yet
      }

      // Create scenes from story segments - only include columns that exist in the database
      // Based on schema: id, created_at, project_id, scene_number, title, description, location, resources, checklist
      const scenesToCreate = segments.map((segment, index) => ({
        project_id: project.id,
        scene_number: index + 1,
        title: segment.title,
        description: segment.description || '',
        location: segment.location || '',
        // Store location_type and location_notes in resources since they don't have dedicated columns
        resources: {
          ...(project.resources || {}),
          location_type: segment.location_type || 'Indoor',
          location_notes: segment.location_notes || ''
        },
        checklist: {}
        // created_at and id will be auto-generated by Supabase
      }));

      console.log('Scenes to create:', scenesToCreate);

      // Insert scenes into database
      const { data: createdScenes, error: scenesError } = await supabase
        .from('scenes_fc2024')
        .insert(scenesToCreate)
        .select();

      if (scenesError) {
        console.error('Database error creating scenes:', scenesError);
        throw new Error(`Failed to create scenes: ${scenesError.message}`);
      }

      console.log('Created scenes:', createdScenes);

      // Also update locations based on story segments
      const uniqueLocations = segments
        .filter(segment => segment.location && segment.location.trim())
        .reduce((acc, segment) => {
          const locationKey = segment.location.toLowerCase();
          if (!acc[locationKey]) {
            acc[locationKey] = {
              id: Date.now() + Math.random(),
              name: segment.location,
              type: segment.location_type,
              notes: segment.location_notes || '',
              equipment_needed: [],
              coordinates: null,
              address: '',
              used_in_scenes: []
            };
          }
          acc[locationKey].used_in_scenes.push(segment.title);
          return acc;
        }, {});

      const locationsArray = Object.values(uniqueLocations);

      // Update project with locations and mark scenes as generated
      const updateData = {
        locations: locationsArray,
        generated_scenes: createdScenes,
        scenes_generated: true
      };

      console.log('Updating project with:', updateData);
      onDataUpdate(updateData);

      alert(`✅ Successfully generated ${createdScenes.length} scenes and ${locationsArray.length} unique locations!`);

    } catch (error) {
      console.error('Error generating scenes:', error);
      alert(`❌ Error generating scenes: ${error.message}. Please check the console for details.`);
    } finally {
      setGeneratingScenes(false);
    }
  };

  return (
    <div className="space-y-8">
      <div className="bg-purple-500/10 border border-purple-500/20 rounded-lg p-4">
        <h4 className="text-lg font-semibold text-white mb-2">Three-Act Story Structure</h4>
        <p className="text-purple-300 text-sm">
          Build your story using the classic three-act structure. Add locations to each segment - these will automatically generate your scenes and filming locations.
        </p>
      </div>

      {/* Acts Overview */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {acts.map((act) => {
          const segmentCount = getSegmentsByAct(act.id).length;
          return (
            <motion.div
              key={act.id}
              className={`bg-gradient-to-br ${act.color} rounded-xl p-6 text-white`}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
            >
              <div className="flex items-center space-x-3 mb-4">
                <div className="bg-white/20 p-2 rounded-lg">
                  <SafeIcon icon={act.icon} className="text-xl" />
                </div>
                <div>
                  <h3 className="text-lg font-semibold">{act.title}</h3>
                  <p className="text-xs opacity-90">{segmentCount} segments</p>
                </div>
              </div>
              <p className="text-sm opacity-90 mb-4">{act.description}</p>
              <div className="space-y-2">
                <h5 className="text-sm font-semibold">Tips:</h5>
                <ul className="text-xs space-y-1 opacity-80">
                  {act.tips.map((tip, index) => (
                    <li key={index}>• {tip}</li>
                  ))}
                </ul>
              </div>
            </motion.div>
          );
        })}
      </div>

      {/* Add New Segment */}
      <motion.div
        className="bg-white/5 border border-white/10 rounded-lg p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <h4 className="text-lg font-semibold text-white mb-4">Add Story Segment</h4>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-sm text-gray-300 mb-2">Segment Title</label>
            <input
              type="text"
              value={newSegment.title}
              onChange={(e) => setNewSegment({ ...newSegment, title: e.target.value })}
              className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500"
              placeholder="e.g., Opening hook, Main challenge, Final resolution"
            />
          </div>
          <div>
            <label className="block text-sm text-gray-300 mb-2">Act</label>
            <select
              value={newSegment.act}
              onChange={(e) => setNewSegment({ ...newSegment, act: e.target.value })}
              className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
            >
              <option value="setup">Setup (Act 1)</option>
              <option value="conflict">Conflict (Act 2)</option>
              <option value="resolution">Resolution (Act 3)</option>
            </select>
          </div>
        </div>

        <div className="mb-4">
          <label className="block text-sm text-gray-300 mb-2">Description</label>
          <textarea
            value={newSegment.description}
            onChange={(e) => setNewSegment({ ...newSegment, description: e.target.value })}
            className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
            rows={3}
            placeholder="Describe what happens in this segment..."
          />
        </div>

        {/* Location Settings */}
        <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-4 mb-4">
          <div className="flex items-center space-x-2 mb-3">
            <SafeIcon icon={FiMapPin} className="text-blue-400" />
            <h5 className="font-semibold text-white">Location & Setting</h5>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
            <div>
              <label className="block text-sm text-gray-300 mb-2">Location Name</label>
              <input
                type="text"
                value={newSegment.location}
                onChange={(e) => setNewSegment({ ...newSegment, location: e.target.value })}
                className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500"
                placeholder="e.g., Living Room, Central Park, Coffee Shop"
              />
            </div>
            <div>
              <label className="block text-sm text-gray-300 mb-2">Location Type</label>
              <select
                value={newSegment.location_type}
                onChange={(e) => setNewSegment({ ...newSegment, location_type: e.target.value })}
                className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
              >
                {locationTypes.map(type => (
                  <option key={type} value={type}>{type}</option>
                ))}
              </select>
            </div>
          </div>
          <div>
            <label className="block text-sm text-gray-300 mb-2">Location Notes</label>
            <textarea
              value={newSegment.location_notes}
              onChange={(e) => setNewSegment({ ...newSegment, location_notes: e.target.value })}
              className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
              rows={2}
              placeholder="Lighting conditions, permissions needed, equipment access..."
            />
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-sm text-gray-300 mb-2">Estimated Duration</label>
            <select
              value={newSegment.duration}
              onChange={(e) => setNewSegment({ ...newSegment, duration: e.target.value })}
              className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
            >
              <option value="15 seconds">15 seconds</option>
              <option value="30 seconds">30 seconds</option>
              <option value="1 minute">1 minute</option>
              <option value="2 minutes">2 minutes</option>
              <option value="3 minutes">3 minutes</option>
              <option value="5 minutes">5 minutes</option>
            </select>
          </div>
        </div>

        <motion.button
          className="w-full px-4 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg transition-all"
          whileHover={{ scale: 1.02 }}
          onClick={handleAddSegment}
          disabled={!newSegment.title.trim()}
        >
          <SafeIcon icon={FiPlus} className="inline mr-2" />
          Add Segment
        </motion.button>
      </motion.div>

      {/* Story Segments by Act */}
      {acts.map((act) => {
        const segments = getSegmentsByAct(act.id);
        if (segments.length === 0) return null;

        return (
          <motion.div
            key={act.id}
            className="bg-white/5 border border-white/10 rounded-lg p-6"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
          >
            <div className="flex items-center space-x-3 mb-4">
              <div className={`bg-gradient-to-r ${act.color} p-2 rounded-lg`}>
                <SafeIcon icon={act.icon} className="text-white" />
              </div>
              <h4 className="text-lg font-semibold text-white">{act.title}</h4>
            </div>

            <div className="space-y-4">
              {segments.map((segment, index) => (
                <motion.div
                  key={segment.id}
                  className="bg-white/5 border border-white/10 rounded-lg p-4"
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: index * 0.1 }}
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1 space-y-3">
                      <div className="flex items-center space-x-2">
                        <div className={`bg-gradient-to-r ${act.color} text-white rounded-full w-8 h-8 flex items-center justify-center text-sm font-bold`}>
                          {index + 1}
                        </div>
                        <input
                          type="text"
                          value={segment.title}
                          onChange={(e) => updateSegment(segment.id, { title: e.target.value })}
                          className="flex-1 px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500"
                          placeholder="Segment title..."
                        />
                      </div>

                      <textarea
                        value={segment.description}
                        onChange={(e) => updateSegment(segment.id, { description: e.target.value })}
                        className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
                        rows={2}
                        placeholder="Describe what happens in this segment..."
                      />

                      {/* Location Info */}
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <input
                          type="text"
                          value={segment.location || ''}
                          onChange={(e) => updateSegment(segment.id, { location: e.target.value })}
                          className="px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500"
                          placeholder="Location name..."
                        />
                        <select
                          value={segment.location_type || 'Indoor'}
                          onChange={(e) => updateSegment(segment.id, { location_type: e.target.value })}
                          className="px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        >
                          {locationTypes.map(type => (
                            <option key={type} value={type}>{type}</option>
                          ))}
                        </select>
                        <select
                          value={segment.duration}
                          onChange={(e) => updateSegment(segment.id, { duration: e.target.value })}
                          className="px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        >
                          <option value="15 seconds">15 seconds</option>
                          <option value="30 seconds">30 seconds</option>
                          <option value="1 minute">1 minute</option>
                          <option value="2 minutes">2 minutes</option>
                          <option value="3 minutes">3 minutes</option>
                          <option value="5 minutes">5 minutes</option>
                        </select>
                      </div>

                      {segment.location && (
                        <div className="flex items-center space-x-2 text-sm">
                          <SafeIcon icon={FiMapPin} className="text-blue-400" />
                          <span className="text-gray-400">
                            {segment.location} ({segment.location_type})
                          </span>
                        </div>
                      )}
                    </div>

                    <motion.button
                      className="ml-4 p-2 bg-red-500/20 hover:bg-red-500/30 rounded-lg transition-all"
                      whileHover={{ scale: 1.05 }}
                      onClick={() => removeSegment(segment.id)}
                    >
                      <SafeIcon icon={FiTrash2} className="text-red-400" />
                    </motion.button>
                  </div>
                </motion.div>
              ))}
            </div>
          </motion.div>
        );
      })}

      {/* Generate Scenes Button */}
      {(project.story_structure || []).length > 0 && (
        <motion.div className="text-center" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
          <motion.button
            className="px-8 py-4 bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white rounded-lg font-semibold text-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            whileHover={{ scale: generatingScenes ? 1 : 1.05 }}
            onClick={generateScenesFromStructure}
            disabled={generatingScenes}
          >
            <SafeIcon icon={generatingScenes ? FiClock : FiSave} className="inline mr-2" />
            {generatingScenes ? 'Generating Scenes...' : 'Generate Scenes & Locations'}
          </motion.button>
          <p className="text-gray-400 text-sm mt-2">
            This will create scenes and locations based on your story segments
          </p>
          <div className="text-xs text-purple-300 mt-2 space-y-1">
            <p>• Each story segment becomes a scene</p>
            <p>• Locations are automatically extracted and organized</p>
            <p>• Scenes will be available in the Shot List builder</p>
          </div>

          {/* Show if scenes already generated */}
          {project.scenes_generated && (
            <div className="mt-4 p-3 bg-green-500/10 border border-green-500/20 rounded-lg">
              <p className="text-green-400 text-sm">
                ✅ Scenes already generated! You can regenerate them or proceed to Shot List.
              </p>
            </div>
          )}
        </motion.div>
      )}
    </div>
  );
};

export default StoryStructureBuilder;